{"title":"async 和 await","date":"2017-05-23T10:29:18.000Z","slug":"async","comments":true,"updated":"2019-03-23T10:41:32.908Z","content":"<p>一个函数如果加上 async ，那么该函数就会返回一个 Promise<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test()); <span class=\"comment\">// -&gt; Promise &#123;&lt;resolved&gt;: \"1\"&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>可以把 async 看成将函数返回值使用 Promise.resolve() 包裹了下。</p>\n<blockquote>\n<h1 id=\"注意await-只能在-async-函数中使用\"><a href=\"#注意await-只能在-async-函数中使用\" class=\"headerlink\" title=\"注意await 只能在 async 函数中使用\"></a><code>注意</code>await 只能在 async 函数中使用</h1></blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'finish'</span>)</span><br><span class=\"line\">      resolve(<span class=\"string\">\"sleep\"</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> value = <span class=\"keyword\">await</span> sleep();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"object\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test()</span><br></pre></td></tr></table></figure>\n<p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> ,因为 await 会等待 sleep 函数 resolve ,所以即使后面是<code>同步代码</code>，也不会先去执行同步代码再来执行<code>异步代码</code>。</p>\n<p>async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>\n<p>下面来看一个使用 await 的代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  a = a + <span class=\"keyword\">await</span> <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>, a) <span class=\"comment\">// -&gt; '2' 10</span></span><br><span class=\"line\">  a = (<span class=\"keyword\">await</span> <span class=\"number\">10</span>) + a</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'3'</span>, a) <span class=\"comment\">// -&gt; '3' 20</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b()</span><br><span class=\"line\">a++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>, a) <span class=\"comment\">// -&gt; '1' 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// result  1 1</span></span><br><span class=\"line\"><span class=\"comment\">//         2 10</span></span><br><span class=\"line\"><span class=\"comment\">//         3 20</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于以上代码你可能会有疑惑，这里说明下原理</p>\n</blockquote>\n<p>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为在 await 内部实现了 generators ，generators 会保留堆栈中东西，所以这时候 a = 0 被保存了下来<br>因为 await 是异步操作，遇到await就会立即返回一个pending状态的Promise对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 console.log(‘1’, a)<br>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 10<br>然后后面就是常规执行代码了</p>\n","prev":{"title":"Eslint","slug":"Eslint"},"next":{"title":"vue双向绑定","slug":"Vue"},"link":"https://annwvn.github.io/yangliu.github.io/post/async/","toc":[{"title":"","id":"注意await-只能在-async-函数中使用","index":"1"}]}