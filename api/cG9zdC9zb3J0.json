{"title":"排序","date":"2016-02-18T02:13:01.000Z","slug":"sort","comments":true,"updated":"2019-03-29T06:35:37.381Z","content":"<h1 id=\"1-冒泡排序\">1.冒泡排序<a href=\"post/sort#1-冒泡排序\"></a></h1><h3 id=\"原理\">原理<a href=\"post/sort#原理\"></a></h3><blockquote>\n<p>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端</p>\n</blockquote>\n<h3 id=\"算法描述\">算法描述<a href=\"post/sort#算法描述\"></a></h3><p>·比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>·对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>·针对所有的元素重复以上的步骤，除了最后一个；<br>·重复步骤1~3，直到排序完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;        <span class=\"comment\">// 相邻元素两两对比</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> temp = arr[j+<span class=\"number\">1</span>];        <span class=\"comment\">// 如果后一个元素大就交换位置</span></span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = arr[j];          </span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-选择排序\">2.选择排序<a href=\"post/sort#2-选择排序\"></a></h1><h3 id=\"原理-1\">原理<a href=\"post/sort#原理-1\"></a></h3><blockquote>\n<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>\n</blockquote>\n<h3 id=\"算法描述-1\">算法描述<a href=\"post/sort#算法描述-1\"></a></h3><p>·初始状态：无序区为R[1..n]，有序区为空；<br>·第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将·它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>·n-1趟结束，数组有序化了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> minIndex, temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        minIndex = i; <span class=\"comment\">// 将最小数的索引保存</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;  <span class=\"comment\">//从第二个数开始一个循坏</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"comment\">// 寻找最小的数</span></span><br><span class=\"line\">                minIndex = j;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i]; <span class=\"comment\">//temp 找出最小的数保存</span></span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"算法分析\">算法分析<a href=\"post/sort#算法分析\"></a></h3><blockquote>\n<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>\n</blockquote>\n<h1 id=\"3-插入排序\">3.插入排序<a href=\"post/sort#3-插入排序\"></a></h1><h3 id=\"原理-2\">原理<a href=\"post/sort#原理-2\"></a></h3><blockquote>\n<p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n</blockquote>\n<h3 id=\"算法描述-2\">算法描述<a href=\"post/sort#算法描述-2\"></a></h3><p>·从第一个元素开始，该元素可以认为已经被排序；<br>·取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>·如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>·重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>·将新元素插入到该位置后；<br>·重复步骤2~5。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> preIndex, current;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        preIndex = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        current = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class=\"line\">            arr[preIndex + <span class=\"number\">1</span>] = arr[preIndex];</span><br><span class=\"line\">            preIndex--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-快速排序\">4.快速排序<a href=\"post/sort#4-快速排序\"></a></h1><h3 id=\"原理-3\">原理<a href=\"post/sort#原理-3\"></a></h3><blockquote>\n<p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n</blockquote>\n<h3 id=\"算法描述-3\">算法描述<a href=\"post/sort#算法描述-3\"></a></h3><p>·从数列中挑出一个元素，称为 “基准”（pivot）；<br>·重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，·该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>·递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr, left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length,</span><br><span class=\"line\">        partitionIndex,</span><br><span class=\"line\">        left = <span class=\"keyword\">typeof</span> left != <span class=\"string\">'number'</span> ? <span class=\"number\">0</span> : left,</span><br><span class=\"line\">        right = <span class=\"keyword\">typeof</span> right != <span class=\"string\">'number'</span> ? len - <span class=\"number\">1</span> : right;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">        partitionIndex = partition(arr, left, right);</span><br><span class=\"line\">        quickSort(arr, left, partitionIndex<span class=\"number\">-1</span>);</span><br><span class=\"line\">        quickSort(arr, partitionIndex+<span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">arr, left ,right</span>) </span>&#123;     <span class=\"comment\">// 分区操作</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pivot = left,                      <span class=\"comment\">// 设定基准值（pivot）</span></span><br><span class=\"line\">        index = pivot + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = index; i &lt;= right; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class=\"line\">            swap(arr, i, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(arr, pivot, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, i, j</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"5-希尔排序\">5.希尔排序<a href=\"post/sort#5-希尔排序\"></a></h1><h3 id=\"原理-4\">原理<a href=\"post/sort#原理-4\"></a></h3><blockquote>\n<p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>\n</blockquote>\n<h3 id=\"算法描述-4\">算法描述<a href=\"post/sort#算法描述-4\"></a></h3><p>·选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>·按增量序列个数k，对序列进行k 趟排序；<br>·每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改于 2019-03-06</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> gap = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>); gap &gt; <span class=\"number\">0</span>; gap = <span class=\"built_in\">Math</span>.floor(gap / <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> current = arr[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j - gap &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class=\"line\">                 arr[j] = arr[j - gap];</span><br><span class=\"line\">                 j = j - gap;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j] = current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"6-计数排序\">6.计数排序<a href=\"post/sort#6-计数排序\"></a></h1><h3 id=\"原理-5\">原理<a href=\"post/sort#原理-5\"></a></h3><blockquote>\n<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>\n</blockquote>\n<h3 id=\"算法描述-5\">算法描述<a href=\"post/sort#算法描述-5\"></a></h3><p>·找出待排序的数组中最大和最小的元素；<br>·统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>·对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>·反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">arr, maxValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bucket = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(maxValue + <span class=\"number\">1</span>),</span><br><span class=\"line\">        sortedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        arrLen = arr.length,</span><br><span class=\"line\">        bucketLen = maxValue + <span class=\"number\">1</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!bucket[arr[i]]) &#123;</span><br><span class=\"line\">            bucket[arr[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bucket[arr[i]]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(bucket[j] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            arr[sortedIndex++] = j;</span><br><span class=\"line\">            bucket[j]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"7-基数排序\">7.基数排序<a href=\"post/sort#7-基数排序\"></a></h1><h3 id=\"原理-6\">原理<a href=\"post/sort#原理-6\"></a></h3><blockquote>\n<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>\n</blockquote>\n<h3 id=\"算法描述-6\">算法描述<a href=\"post/sort#算法描述-6\"></a></h3><p>·取得数组中的最大数，并取得位数；<br>·arr为原始数组，从最低位开始取每个位组成radix数组；<br>·对radix进行计数排序（利用计数排序适用于小范围数的特点）；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> counter = [];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">arr, maxDigit</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mod = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dev = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; maxDigit; i++, dev *= <span class=\"number\">10</span>, mod *= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bucket = <span class=\"built_in\">parseInt</span>((arr[j] % mod) / dev);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(counter[bucket]==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                counter[bucket] = [];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            counter[bucket].push(arr[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(counter[j]!=<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ((value = counter[j].shift()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                      arr[pos++] = value;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"8-归并排序\">8.归并排序<a href=\"post/sort#8-归并排序\"></a></h1><h3 id=\"原理-7\">原理<a href=\"post/sort#原理-7\"></a></h3><blockquote>\n<p>建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>\n</blockquote>\n<h3 id=\"算法描述-7\">算法描述<a href=\"post/sort#算法描述-7\"></a></h3><p>·把长度为n的输入序列分成两个长度为n/2的子序列；<br>·对这两个子序列分别采用归并排序；<br>·将两个排序好的子序列合并成一个最终的排序序列。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> middle = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>),</span><br><span class=\"line\">        left = arr.slice(<span class=\"number\">0</span>, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length&gt;<span class=\"number\">0</span> &amp;&amp; right.length&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[<span class=\"number\">0</span>] &lt;= right[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"9-堆排序\">9.堆排序<a href=\"post/sort#9-堆排序\"></a></h1><h3 id=\"原理-8\">原理<a href=\"post/sort#原理-8\"></a></h3><blockquote>\n<p>利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n</blockquote>\n<h3 id=\"算法描述-8\">算法描述<a href=\"post/sort#算法描述-8\"></a></h3><p>·将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>·将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>·由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> len;    <span class=\"comment\">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildMaxHeap</span>(<span class=\"params\">arr</span>) </span>&#123;   <span class=\"comment\">// 建立大顶堆</span></span><br><span class=\"line\">    len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(len/<span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        heapify(arr, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapify</span>(<span class=\"params\">arr, i</span>) </span>&#123;     <span class=\"comment\">// 堆调整</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>,</span><br><span class=\"line\">        right = <span class=\"number\">2</span> * i + <span class=\"number\">2</span>,</span><br><span class=\"line\">        largest = i;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class=\"line\">        largest = left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class=\"line\">        largest = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">        swap(arr, i, largest);</span><br><span class=\"line\">        heapify(arr, largest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, i, j</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    buildMaxHeap(arr);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        swap(arr, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">        heapify(arr, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"10-桶排序\">10.桶排序<a href=\"post/sort#10-桶排序\"></a></h1><h3 id=\"原理-9\">原理<a href=\"post/sort#原理-9\"></a></h3><blockquote>\n<p>计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>\n</blockquote>\n<h3 id=\"算法描述-9\">算法描述<a href=\"post/sort#算法描述-9\"></a></h3><p>·设置一个定量的数组当作空桶；<br>·遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>·对每个不是空的桶进行排序；<br>·从不是空的桶里把排好序的数据拼接起来<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">arr, bucketSize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">var</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> minValue = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> maxValue = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class=\"line\">          minValue = arr[i];                <span class=\"comment\">// 输入数据的最小值</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class=\"line\">          maxValue = arr[i];                <span class=\"comment\">// 输入数据的最大值</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 桶的初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> DEFAULT_BUCKET_SIZE = <span class=\"number\">5</span>;            <span class=\"comment\">// 设置桶的默认数量为5</span></span><br><span class=\"line\">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bucketCount = <span class=\"built_in\">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> buckets = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(bucketCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class=\"line\">        buckets[i] = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 利用映射函数将数据分配到各个桶中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        buckets[<span class=\"built_in\">Math</span>.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    arr.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class=\"line\">        insertionSort(buckets[i]);                      <span class=\"comment\">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class=\"line\">            arr.push(buckets[i][j]);                     </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"vue双向绑定","slug":"Vue"},"next":{"title":"跨域","slug":"跨域"},"link":"https://annwvn.github.io/yangliu.github.io/post/sort/","toc":[{"title":"1.冒泡排序","id":"1-冒泡排序","index":"1"},{"title":"2.选择排序","id":"2-选择排序","index":"2"},{"title":"3.插入排序","id":"3-插入排序","index":"3"},{"title":"4.快速排序","id":"4-快速排序","index":"4"},{"title":"5.希尔排序","id":"5-希尔排序","index":"5"},{"title":"6.计数排序","id":"6-计数排序","index":"6"},{"title":"7.基数排序","id":"7-基数排序","index":"7"},{"title":"8.归并排序","id":"8-归并排序","index":"8"},{"title":"9.堆排序","id":"9-堆排序","index":"9"},{"title":"10.桶排序","id":"10-桶排序","index":"10"}]}