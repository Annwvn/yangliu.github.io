{"title":"排序","date":"2016-02-18T02:13:01.000Z","slug":"sort","comments":true,"updated":"2019-03-29T06:23:22.330Z","content":"<h1 id=\"冒泡排序\">冒泡排序<a href=\"post/sort#冒泡排序\"></a></h1><h3 id=\"原理\">原理<a href=\"post/sort#原理\"></a></h3><blockquote>\n<p>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端</p>\n</blockquote>\n<h3 id=\"算法描述\">算法描述<a href=\"post/sort#算法描述\"></a></h3><p>·比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>·对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>·针对所有的元素重复以上的步骤，除了最后一个；<br>·重复步骤1~3，直到排序完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;        <span class=\"comment\">// 相邻元素两两对比</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> temp = arr[j+<span class=\"number\">1</span>];        <span class=\"comment\">// 如果后一个元素大就交换位置</span></span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = arr[j];          </span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"选择排序\">选择排序<a href=\"post/sort#选择排序\"></a></h1><h3 id=\"原理-1\">原理<a href=\"post/sort#原理-1\"></a></h3><blockquote>\n<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>\n</blockquote>\n<h3 id=\"算法描述-1\">算法描述<a href=\"post/sort#算法描述-1\"></a></h3><p>·初始状态：无序区为R[1..n]，有序区为空；<br>·第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将·它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>·n-1趟结束，数组有序化了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> minIndex, temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        minIndex = i; <span class=\"comment\">// 将最小数的索引保存</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;  <span class=\"comment\">//从第二个数开始一个循坏</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"comment\">// 寻找最小的数</span></span><br><span class=\"line\">                minIndex = j;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i]; <span class=\"comment\">//temp 找出最小的数保存</span></span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"算法分析\">算法分析<a href=\"post/sort#算法分析\"></a></h3><blockquote>\n<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>\n</blockquote>\n<h1 id=\"插入排序\">插入排序<a href=\"post/sort#插入排序\"></a></h1><h3 id=\"原理-2\">原理<a href=\"post/sort#原理-2\"></a></h3><blockquote>\n<p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n</blockquote>\n<h3 id=\"算法描述-2\">算法描述<a href=\"post/sort#算法描述-2\"></a></h3><p>·从第一个元素开始，该元素可以认为已经被排序；<br>·取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>·如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>·重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>·将新元素插入到该位置后；<br>·重复步骤2~5。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> preIndex, current;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        preIndex = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        current = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class=\"line\">            arr[preIndex + <span class=\"number\">1</span>] = arr[preIndex];</span><br><span class=\"line\">            preIndex--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"快速排序\">快速排序<a href=\"post/sort#快速排序\"></a></h1><h3 id=\"原理-3\">原理<a href=\"post/sort#原理-3\"></a></h3><blockquote>\n<p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n</blockquote>\n<h3 id=\"算法描述-3\">算法描述<a href=\"post/sort#算法描述-3\"></a></h3><blockquote>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"选择排序-1\">选择排序<a href=\"post/sort#选择排序-1\"></a></h1><h3 id=\"原理-4\">原理<a href=\"post/sort#原理-4\"></a></h3><blockquote>\n</blockquote>\n<h3 id=\"算法描述-4\">算法描述<a href=\"post/sort#算法描述-4\"></a></h3><blockquote>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"选择排序-2\">选择排序<a href=\"post/sort#选择排序-2\"></a></h1><h3 id=\"原理-5\">原理<a href=\"post/sort#原理-5\"></a></h3><blockquote>\n</blockquote>\n<h3 id=\"算法描述-5\">算法描述<a href=\"post/sort#算法描述-5\"></a></h3><blockquote>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","prev":{"title":"vue双向绑定","slug":"Vue"},"next":{"title":"跨域","slug":"跨域"},"link":"https://annwvn.github.io/yangliu.github.io/post/sort/","toc":[{"title":"冒泡排序","id":"冒泡排序","index":"1"},{"title":"选择排序","id":"选择排序","index":"2"},{"title":"插入排序","id":"插入排序","index":"3"},{"title":"快速排序","id":"快速排序","index":"4"},{"title":"选择排序","id":"选择排序-1","index":"5"},{"title":"选择排序","id":"选择排序-2","index":"6"}]}